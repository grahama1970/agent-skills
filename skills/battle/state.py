"""
Battle Skill - State Management
Dataclasses and BattleState for externalized memory pattern.
"""
from __future__ import annotations

import json
import threading
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Any

from config import BATTLES_DIR


# -----------------------------------------------------------------------------
# Enums
# -----------------------------------------------------------------------------

class AttackType(str, Enum):
    """Types of attacks Red Team can perform."""
    SCAN = "scan"
    AUDIT = "audit"
    EXPLOIT = "exploit"
    INJECTION = "injection"


class DefenseType(str, Enum):
    """Types of defenses Blue Team can apply."""
    PATCH = "patch"
    HARDEN = "harden"
    BLOCK = "block"
    VALIDATE = "validate"


class TwinMode(str, Enum):
    """Digital twin mode - how the twin is created and isolated."""
    GIT_WORKTREE = "git_worktree"  # Source code: git worktree isolation
    DOCKER = "docker"              # Container: Docker-based isolation
    QEMU = "qemu"                  # Hardware: QEMU emulation for firmware/MCU
    COPY = "copy"                  # Fallback: simple file copy


# -----------------------------------------------------------------------------
# Data Classes
# -----------------------------------------------------------------------------

@dataclass
class Finding:
    """A vulnerability or security issue found by Red Team."""
    id: str
    type: AttackType
    severity: str  # critical, high, medium, low
    description: str
    file_path: str | None = None
    line_number: int | None = None
    exploit_proof: str | None = None
    timestamp: str = field(default_factory=lambda: datetime.now().isoformat())
    tags: list[str] = field(default_factory=list)


@dataclass
class Patch:
    """A fix generated by Blue Team."""
    id: str
    finding_id: str
    type: DefenseType
    diff: str
    verified: bool = False
    functionality_preserved: bool = False
    timestamp: str = field(default_factory=lambda: datetime.now().isoformat())


@dataclass
class RoundResult:
    """Result of a single battle round."""
    round_number: int
    red_findings: list[Finding] = field(default_factory=list)
    blue_patches: list[Patch] = field(default_factory=list)
    red_score: float = 0.0
    blue_score: float = 0.0
    duration_seconds: float = 0.0
    timestamp: str = field(default_factory=lambda: datetime.now().isoformat())


# -----------------------------------------------------------------------------
# Battle State
# -----------------------------------------------------------------------------

@dataclass
class BattleState:
    """Complete state of a battle - externalized memory with thread-safe access."""
    battle_id: str
    target_path: str
    max_rounds: int
    current_round: int = 0
    status: str = "pending"  # pending, running, paused, completed

    # Cumulative scores
    red_total_score: float = 0.0
    blue_total_score: float = 0.0

    # History
    rounds: list[RoundResult] = field(default_factory=list)
    all_findings: list[Finding] = field(default_factory=list)
    all_patches: list[Patch] = field(default_factory=list)

    # Metrics
    tdsr: float = 0.0  # True Defense Success Rate
    fdsr: float = 0.0  # Fake Defense Success Rate
    asc: int = 0       # Attack Success Count

    # Timestamps
    started_at: str | None = None
    completed_at: str | None = None
    last_checkpoint: str | None = None

    # Concurrent execution state
    red_active: bool = False
    blue_active: bool = False
    red_action: str = "idle"
    blue_action: str = "idle"

    # Thread safety
    _lock: threading.Lock = field(default_factory=threading.Lock, repr=False)

    def to_dict(self) -> dict[str, Any]:
        """Serialize to dict for JSON storage."""
        return {
            "battle_id": self.battle_id,
            "target_path": self.target_path,
            "max_rounds": self.max_rounds,
            "current_round": self.current_round,
            "status": self.status,
            "red_total_score": self.red_total_score,
            "blue_total_score": self.blue_total_score,
            "rounds": [
                {
                    "round_number": r.round_number,
                    "red_findings": [
                        {
                            "id": f.id,
                            "type": f.type.value,
                            "severity": f.severity,
                            "description": f.description,
                            "file_path": f.file_path,
                            "line_number": f.line_number,
                            "exploit_proof": f.exploit_proof,
                            "timestamp": f.timestamp,
                            "tags": f.tags,
                        }
                        for f in r.red_findings
                    ],
                    "blue_patches": [
                        {
                            "id": p.id,
                            "finding_id": p.finding_id,
                            "type": p.type.value,
                            "diff": p.diff,
                            "verified": p.verified,
                            "functionality_preserved": p.functionality_preserved,
                            "timestamp": p.timestamp,
                        }
                        for p in r.blue_patches
                    ],
                    "red_score": r.red_score,
                    "blue_score": r.blue_score,
                    "duration_seconds": r.duration_seconds,
                    "timestamp": r.timestamp,
                }
                for r in self.rounds
            ],
            "all_findings": [
                {
                    "id": f.id,
                    "type": f.type.value,
                    "severity": f.severity,
                    "description": f.description,
                    "file_path": f.file_path,
                    "line_number": f.line_number,
                    "exploit_proof": f.exploit_proof,
                    "timestamp": f.timestamp,
                    "tags": f.tags,
                }
                for f in self.all_findings
            ],
            "all_patches": [
                {
                    "id": p.id,
                    "finding_id": p.finding_id,
                    "type": p.type.value,
                    "diff": p.diff,
                    "verified": p.verified,
                    "functionality_preserved": p.functionality_preserved,
                    "timestamp": p.timestamp,
                }
                for p in self.all_patches
            ],
            "tdsr": self.tdsr,
            "fdsr": self.fdsr,
            "asc": self.asc,
            "started_at": self.started_at,
            "completed_at": self.completed_at,
            "last_checkpoint": self.last_checkpoint,
        }

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> BattleState:
        """Deserialize from dict."""
        state = cls(
            battle_id=data["battle_id"],
            target_path=data["target_path"],
            max_rounds=data["max_rounds"],
            current_round=data["current_round"],
            status=data["status"],
            red_total_score=data["red_total_score"],
            blue_total_score=data["blue_total_score"],
            tdsr=data.get("tdsr", 0.0),
            fdsr=data.get("fdsr", 0.0),
            asc=data.get("asc", 0),
            started_at=data.get("started_at"),
            completed_at=data.get("completed_at"),
            last_checkpoint=data.get("last_checkpoint"),
        )
        # Reconstruct Finding objects
        state.all_findings = [
            Finding(
                id=f["id"],
                type=AttackType(f["type"]),
                severity=f["severity"],
                description=f["description"],
                file_path=f.get("file_path"),
                line_number=f.get("line_number"),
                exploit_proof=f.get("exploit_proof"),
                timestamp=f.get("timestamp", ""),
                tags=f.get("tags", []),
            )
            for f in data.get("all_findings", [])
        ]
        # Reconstruct Patch objects
        state.all_patches = [
            Patch(
                id=p["id"],
                finding_id=p["finding_id"],
                type=DefenseType(p["type"]),
                diff=p["diff"],
                verified=p.get("verified", False),
                functionality_preserved=p.get("functionality_preserved", False),
                timestamp=p.get("timestamp", ""),
            )
            for p in data.get("all_patches", [])
        ]
        # Reconstruct RoundResult objects
        state.rounds = [
            RoundResult(
                round_number=r["round_number"],
                red_findings=[
                    Finding(
                        id=f["id"],
                        type=AttackType(f["type"]),
                        severity=f["severity"],
                        description=f["description"],
                        file_path=f.get("file_path"),
                        line_number=f.get("line_number"),
                        exploit_proof=f.get("exploit_proof"),
                        timestamp=f.get("timestamp", ""),
                        tags=f.get("tags", []),
                    )
                    for f in r.get("red_findings", [])
                ],
                blue_patches=[
                    Patch(
                        id=p["id"],
                        finding_id=p["finding_id"],
                        type=DefenseType(p["type"]),
                        diff=p["diff"],
                        verified=p.get("verified", False),
                        functionality_preserved=p.get("functionality_preserved", False),
                        timestamp=p.get("timestamp", ""),
                    )
                    for p in r.get("blue_patches", [])
                ],
                red_score=r.get("red_score", 0.0),
                blue_score=r.get("blue_score", 0.0),
                duration_seconds=r.get("duration_seconds", 0.0),
                timestamp=r.get("timestamp", ""),
            )
            for r in data.get("rounds", [])
        ]
        return state

    def save(self) -> Path:
        """Save state to checkpoint file."""
        BATTLES_DIR.mkdir(parents=True, exist_ok=True)
        self.last_checkpoint = datetime.now().isoformat()
        path = BATTLES_DIR / f"{self.battle_id}.json"
        path.write_text(json.dumps(self.to_dict(), indent=2))
        return path

    @classmethod
    def load(cls, battle_id: str) -> BattleState | None:
        """Load state from checkpoint file."""
        path = BATTLES_DIR / f"{battle_id}.json"
        if not path.exists():
            return None
        return cls.from_dict(json.loads(path.read_text()))
